# Установка и запуск контейнеров

В этом проекте представлены два варианта `Dockerfile` для создания контейнеров: один с хорошими практиками, а другой с плохими. Описание того, как запускать оба контейнера, находится ниже.

## 1. Dockerfile с хорошими практиками

Этот `Dockerfile` использует `Poetry` для управления зависимостями и установкой, минимизирует слои Docker-образа и следит за правильной изоляцией окружений.

### Шаги для сборки и запуска:

1. **Построение Docker-образа**:

    Чтобы собрать Docker-образ с хорошими практиками, выполните следующую команду:

    ```bash
    sudo docker build -t streamlit-app-good -f Dockerfile .
    ```

2. **Запуск контейнера**:

    После того как образ собран, можно запустить контейнер с помощью команды:

    ```bash
    sudo docker run -p 27369:27369 streamlit-app-good
    ```

    Теперь вы можете открыть приложение Streamlit в браузере по адресу:

    - [Local URL](http://localhost:27369)
    - [External URL](http://<your-external-ip>:27369)

### Объяснение хороших практик:

1. **Использование Poetry для управления зависимостями**: Poetry создаёт виртуальное окружение и изолирует зависимости проекта, что позволяет избежать конфликтов версий и лишних зависимостей.
   
2. **Оптимизация Docker-образа**: Сначала устанавливаются зависимости, а затем копируются файлы, чтобы избежать повторной установки зависимостей при изменении других файлов проекта. Это помогает сохранить слой кэша для зависимостей.

3. **Минимизация слоев**: Использование минимальных слоёв для установки зависимостей и выполнения команд, что помогает уменьшить размер Docker-образа.

---

## 2. Dockerfile с плохими практиками

Этот `Dockerfile` использует устаревшую практику для управления зависимостями через `pip` и копирует весь проект до установки зависимостей, что может привести к ненужной перезагрузке установок при изменении файлов.

### Шаги для сборки и запуска:

1. **Построение Docker-образа**:

    Чтобы собрать Docker-образ с плохими практиками, выполните следующую команду:

    ```bash
    sudo docker build -t streamlit-app-bad -f Dockerfile_bad .
    ```

2. **Запуск контейнера**:

    После того как образ собран, запустите контейнер с помощью команды:

    ```bash
    sudo docker run -p 27369:27369 streamlit-app-bad
    ```

    Приложение Streamlit будет доступно по тому же порту:

    - [Local URL](http://localhost:27369)

### Объяснение плохих практик:

1. **Использование `pip` для установки зависимостей**: Это менее предпочтительно по сравнению с использованием Poetry, так как `pip` не управляет виртуальными окружениями и может привести к конфликтам зависимостей.

2. **Копирование всего проекта до установки зависимостей**: Это приводит к тому, что при изменении любых файлов проекта будет происходить повторная установка зависимостей, даже если они не изменились, что замедляет сборку образа.

3. **Отсутствие использования кэширования слоёв**: Из-за неправильной последовательности команд все слои образа пересоздаются при каждом изменении, что увеличивает время сборки.

---

## 3. Плохие практики при использовании контейнеров

1. **Отсутствие использования томов (volumes) для хранения данных**: При использовании контейнеров часто возникает необходимость сохранять данные между запусками контейнеров. Без томов эти данные теряются при остановке контейнера, что может быть проблемой в реальных приложениях, например, для баз данных или логов. Пример правильного использования томов:

    ```bash
    sudo docker run -v /path/to/local/folder:/app/data -p 27369:27369 streamlit-app-good
    ```

2. **Запуск контейнера с параметром `--rm`**: Использование флага `--rm` при запуске контейнера удаляет контейнер после его остановки, что затрудняет диагностику ошибок и сбор данных о контейнере. Это также мешает сохранению состояния контейнера в случае необходимости его повторного использования.

    Вместо этого лучше запускать контейнер без этого флага и удалять его вручную, когда это необходимо:

    ```bash
    sudo docker run -p 27369:27369 streamlit-app-good
    ```

---

## Когда НЕ стоит использовать контейнеры:

1. **Для одноразовых простых приложений**: Если приложение не предполагает многократного использования или сложной инфраструктуры, использование контейнеров может быть излишним и усложнить процесс разработки и деплоя.

2. **Для приложений с высокой нагрузкой и сложными зависимостями**: Если приложение требует сложной настройки и постоянных изменений в конфигурациях, контейнеры могут добавить дополнительную сложность в процессе разработки и тестирования.

